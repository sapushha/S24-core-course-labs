# Why I chose Flask?

Simplicity and Minimalism: Flask is known for its simplicity and minimalistic approach. It does not impose a specific way of doing things and allows developers to have more flexibility in designing their applications.

Flexibility: Flask provides a lot of flexibility in terms of choosing components and libraries for your application. It does not come with a built-in database abstraction layer, allowing you to choose the database technology that best suits your needs.

Integration with Other Libraries: Flask integrates well with other Python libraries, such as Jinja2 for templating and ItsDangerous for secure data serialization.

Testing Support: Flask provides integrated support for unit testing, making it easier to write tests for your application.

Deployment Options: Flask offers various deployment options, including cloud platforms like Google App Engine. This allows you to easily deploy your Flask application to the cloud and make it accessible to others.

## What best practices did I apply in the web application?

Code Quality: Following coding best practices such as using proper naming conventions, writing clean and maintainable code, and adhering to coding standards. This helps improve the readability, maintainability, and scalability of the application.

Testing: Implementing a comprehensive testing strategy, including unit tests, integration tests, and end-to-end tests, to ensure the application functions as expected and to catch any bugs or issues early in the development process.

Documentation: Providing clear and comprehensive documentation for the application, including code comments, API documentation, and user guides. This helps other developers understand and work with the codebase and assists users in effectively using the application.

Version Control: Using a version control system, such as Git, to track changes to the codebase and facilitate collaboration among team members. This allows for easy rollback of changes, code review, and better code management.

## Unit Tests I have created

### test_home Test

This test checks the home route ("/") of the application.
It sends a GET request to the home route using the test client and asserts that the response status code is 200 (indicating a successful request) and that the response data contains the string "Current Time in Moscow" .

### test_home_time Test

This test also checks the home route ("/") of the application but with a mocked time.
It uses the monkeypatch fixture to mock the current time to January 1, 2024, 12:00:00.
The test then sends a GET request to the home route using the test client and asserts that the response status code is 200 and that the response data contains the string "2024-01-01 12:00:00" .
